<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<TEI  xmlns="http://www.tei-c.org/ns/1.0" xmlns:rng="http://relaxng.org/ns/structure/1.0"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Data Model specification for Beethovens Werkstatt – Module 2</title>
                <respStmt>
                    <resp>Authored by</resp>
                    <name xml:id="KH">Kristin Herold</name>
                    <name xml:id="JK">Johannes Kepper</name>
                </respStmt>
                <respStmt>
                    <resp>In collaboration with</resp>
                    <name xml:id="BRA">Bernhard R. Appel</name>
                    <name xml:id="SC">Susanne Cox</name>
                    <name xml:id="RM">Ran Mo</name>
                    <name xml:id="AM">Andreas Münzmay</name>
                    <name xml:id="EN">Elisa Novara</name>
                    <name xml:id="RS">Richard Sänger</name>
                    <name xml:id="AS">Agnes Seipelt</name>
                    <name xml:id="JV">Joachim Veit</name>
                </respStmt>
            </titleStmt>
            <publicationStmt>
                <p/>
            </publicationStmt>
            <sourceDesc>
                <p/>
            </sourceDesc>
        </fileDesc>
        <revisionDesc>
            <change n="1" when="2019-01-28" who="#KH #JK">
                <desc>Initial setup of the ODD.</desc>
            </change>
            <change n="2" from="2019-02" to="2020-04" who="#AS #JK #KH #RM">
                <desc>continous extensions and adjustments due to the work on modul 2 of the project beethovens werkstatt</desc>
            </change>
            <change n="3" when="2020-04" who="#KH #AS">
                <desc>add Transkriptions- und Codierungsrichtlinien, prepared by Agnes Seipelt</desc>
            </change>
        </revisionDesc>
    </teiHeader>
    <text>
        <body>
            <table rows="28" cols="4">
                <head type="main"><hi rend="bold">Transkriptions- und Codierungsrichtlinien</hi></head>
                <head type="sub">(Sortierung alphabetisch nach fettgedruckten Phänomenen)</head>
                <row role="label">
                    <cell>Phänomen</cell>
                    <cell>Transkription</cell>
                    <cell>Codierungsbeispiel</cell>
                    <cell>im Schema beschrieben?</cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">8</hi>va-Zeichen</cell>
                    <cell>nach Vorlage<lb/>keine Angaben zur Linienform</cell>
                    <cell>
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <octave xml:id="x879c7e1e" startid="#xffc0650f" endid="#xf5c9eb5d" staff="4"  dis.place="above" dis="8"/></egXML>
                        <tag>@oct.ges</tag> an betreffenden Noten 
                        kein <tag>@lform</tag>
                    </cell>
                    <cell>ja</cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Abgekürzte</hi> und alte Schreibweisen</cell>
                    <cell>werden aufgelöst und/oder normalisiert</cell>
                    <cell>z.B. <tag>bTrem</tag>, <tag>multiRpt</tag>, <tag>beatRpt</tag> etc. nicht erlaubt</cell>
                    <cell>ja</cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Artikulation</hi></cell>
                    <cell>nach Vorlage</cell>
                    <cell>z.B.
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <dir xml:id="xb45e5d31-61f4-4b7b-a9a4-2ee60065f48c" layer="1" staff="3" place="below" tstamp="1">
                                sempre staccato</dir></egXML>
                    </cell>
                    <cell>?</cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Bindebögen</hi></cell>
                    <cell>Nach Vorlage </cell>
                    <cell>z.B.
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <slur xml:id="x93b9272b" layer="1" staff="2" startid="#x278f22e5" endid="#x6adaacfe"/>
                        </egXML>
                    </cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Bindebögen - Bogenrichtung</hi></cell>
                    <cell>nicht explizit angeben</cell>
                    <cell><att>curvedir</att> nur in Ausnahmefällen (Lesbarkeit)</cell>
                    <cell>nein</cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Dynamikangaben</hi>:<lb/>
                        <hi rend="latintype">f, p, sf</hi>, etc.,
                        <hi rend="latintype">cresc.</hi> und <hi rend="latintype">decresc.</hi>
                    </cell>
                    <cell>Nach Vorlage<lb/>
                        <att>label</att> ist nicht erlaubt<lb/>
                        In op.133 und 134 wurden Dynamikangaben normalisiert (z.B. F: zu f)<lb/> In allen Stimmen unterhalb, außer bei Singstimme: dort oberhalb wegen des Singtexts
                    </cell>
                    <cell> z.B.
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <dynam xml:id="xe7fae01c" tstamp="2" place="below" staff="1">p</dynam>
                        </egXML><lb/>
                        <att>tstamp2</att> nur, wenn <att>extender</att>=true vorhanden, z.B. bei crescendo-Fortsetzungsstrichen
                    </cell>
                    <cell>
                        <ref target="#check_dynam">check_dynam</ref><lb/>
                        <ref target="#controlevents_dynam">controlevents_dynam</ref><lb/>
                    </cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Dynamikangaben</hi>, die sich zwischen den beiden Klaviersystemen befinden und sich auf beide beziehen</cell>
                    <cell>Zählzeit nach Vorlage, Angabe beider staves </cell>
                    <cell>z.B.
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <dynam xml:id="x557e0add" place="between" staff="6 7" tstamp="3" tstamp2="0m+5" extender="true">cres</dynam>
                        </egXML>
                    </cell>
                    <cell>
                        <ref target="#check_dynam_between_space">check_dynam_between_space</ref>
                    </cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Fermaten</hi></cell>
                    <cell>Nach Vorlage<lb/>Nur <att>startid</att> ist erlaubt, außer die Fermate steht auf einem Taktstrich, dann ist auch <att>tstamp</att> erlaubt<lb/>Keine Ortsangabe nötig, außer wenn sie unterhalb des Systems steht, dann <att>place</att>="below"<lb/><att>form</att> und <att>shape</att> sind nicht erlaubt
                    </cell>
                    <cell>
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <fermata xml:id="x02265c21" staff="3" startid="#xf6e96376"/> 
                        </egXML><lb/>
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <fermata xml:id="xeb595273" staff="7" tstamp="3" place="below"/>
                        </egXML>
                    </cell>
                    <cell>
                        <ref target="#controlevents_fermata">controlevents_fermata</ref><lb/>
                        <ref target="#check_fermata_place">check_fermata_place</ref><lb/>
                        <ref target="#fermata_form_shape">check_fermata_form_shape</ref>
                    </cell>
                </row>
                <row role="data">
                    <cell>Gravierende <hi rend="bold">Fehler</hi>/Inkonsistenzen, die viele Folgefehler produzieren, z.B. fehlender Notenschlüssel</cell>
                    <cell>werden korrigiert, in den Daten markiert und mit der betreffenden Stelle verknüpft</cell>
                    <cell>z.B.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <annot type="sic" resp="#BW" plist="#note_x0a0ks359b3e">missing clef change in the first edition; corrected</annot>
                    </egXML>
                    </cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell>Lokale, offensichtliche <hi rend="bold">Fehler</hi>, die keine Folgefehler hervorrufen (z.B. fehlende Pause, Punkt oder Vorzeichen</cell>
                    <cell>werden nicht korrigiert aber in den Daten markiert</cell>
                    <cell>z.B.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <annot type="sic" resp="#BW" plist="#note_49ee-b5a1">Wrong duration of the last note, it should be 8 instead of 4; not corrected</annot>
                    </egXML>
                    </cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell>cresc.u. decresc.-<hi rend="bold">Gabeln</hi></cell>
                    <cell>nach Vorlage<lb/>nur <att>tstamp</att> und <att>tstamp2</att> erlaubt<lb/>cresc.u. decresc.-Gabeln, die sich auf zwei KLaviersysteme beziehen, bekommen die Angabe beider Systeme, s.o. Dynamikangaben
                    </cell>
                    <cell>z.B.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <hairpin xml:id="x0e0f7bfa" staff="2" tstamp="2.5" tstamp2="0m+2.75" form="dim" place="below"/>
                    </egXML>
                    </cell>
                    <cell>
                        <ref target="#controlevents_hairpin">controlevents_hairpin</ref><lb/>
                        <ref target="#hairpin_between_space">check_hairpin_between_space</ref>
                    </cell>
                </row>
                <row role="data">
                    <cell>Noten<hi rend="bold">halsrichtung</hi></cell>
                    <cell>Keine explizite Angabe, außer in Fällen, wo es zur Überlagerung der Stimmen/schlechte Lesbarkeit der Stimmführung im Klavier führen würde<lb/>Ganze Noten dürfen keine Angabe der Halsrichtung bekommen</cell>
                    <cell>z.B.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <note xml:id="x329b8ef8" stem.dir="down"
                            pname="e" oct="5" dur="16" accid.ges="f"/>
                    </egXML>
                    </cell>
                    <cell><ref target="#check_stem.dir_dur1">check_stem.dir_dur1</ref></cell>
                </row>
                <row role="data">
                    <cell>Haltebögen</cell>
                    <cell>werden mit einem Element codiert<lb/>Werden mit <att>startid</att> und <att>endid</att> an jeweilige noten oder Akkorde geknüpft</cell>
                    <cell>z.B.
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <tie xml:id="xb2f614ee" staff="4" startid="#x07a8ae91" endid="#xd600c086"/>
                    </egXML>
                    </cell>
                    <cell>
                        <ref target="#controlevents_tie">controlevents_tie</ref><lb/>
                        <ref target="#check_notes">check_notes</ref>
                        <ref target="#check_chords">check_chords</ref>
                    </cell>
                </row>
                <row role="data">
                    <cell><hi rend="bold">Metrum</hi> z.B. 4/4 oder C</cell>
                    <cell>nach Vorlage<lb/>Metrumangaben in der ersten <tag>scoreDef</tag> eines <tag>mDiv</tag> sind obligatorisch<lb/>Metrumangaben in der <tag>staffDef</tag> sind nicht erlaubt</cell>
                    <cell>z.B.
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <scoreDef xml:id="xf25244be" meter.count="2" meter.unit="2" meter.sym="cut"/>
                        </egXML>
                    </cell>
                    <cell>
                        <ref target="#check_meter">check_meter</ref>
                    </cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
                <row role="data">
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                    <cell></cell>
                </row>
            </table>
            <schemaSpec ident="mei" start="mei" prefix="mei_" ns="http://www.music-encoding.org/ns/mei">
                
                <!-- Declare MEI and XLink namespaces for use in Schematron -->
                <constraintSpec ident="set_ns" scheme="isoschematron" mode="add">
                    <constraint>
                        <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="mei"
                            uri="http://www.music-encoding.org/ns/mei"/>
                        <sch:ns xmlns:sch="http://purl.oclc.org/dsdl/schematron" prefix="xlink"
                            uri="http://www.w3.org/1999/xlink"/>
                    </constraint>
                </constraintSpec>
                
                <moduleRef key="MEI"/>
                <moduleRef key="MEI.analytical"/>
                <moduleRef key="MEI.cmn" except="beamSpan beatRpt bend bracketSpan halfmRpt meterSig meterSigGrp mRpt mRpt2 mSpace multiRpt tupletSpan bTrem"/>
                <moduleRef key="MEI.cmnOrnaments"/>
                <moduleRef key="MEI.frbr"/>
                <moduleRef key="MEI.gestural"/>
                <moduleRef key="MEI.harmony" include="harm"/>
                <moduleRef key="MEI.header" include="componentList altId appInfo application attUsage availability change changeDesc classDecls classification dedication editionsStmt editorialDecl encodingDesc fileDesc langUsage meiHead notesStmt perfMedium perfRes prefResList physDesc physMedium plateNum projectDesc pubStmt revisionDesc segmentation seriesStmt source sourceDesc tagsDecl tagUsage titleStmt unpub work workList"/>
                <moduleRef key="MEI.lyrics"/>
                <moduleRef key="MEI.namesdates" include="corpName geogName persName roleName"/>
                <moduleRef key="MEI.ptrref"/>
                <moduleRef key="MEI.shared"
                    include="address annot barLine bibl biblList biblScope biblStruct body castGrp castItem castList chord clef clefGrp date desc dir dynam ending expansion head identifier label labelAbbr layer layerDef mdiv mei music name note p part parts physLoc pubPlace relation relationList repository resp respStmt rest role roleDesc score scoreDef section space staff staffDef staffGrp syl tempo title titlePage"/>
                <moduleRef key="MEI.visual"/>
                
                <elementSpec ident="mdiv" module="MEI.shared" mode="change">
                    
                    <constraintSpec xml:id="check_meter" ident="check_meter" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:scoreDef">
                                <sch:let name="context" value="ancestor::mei:*[local-name() = ('score','part')][1]"/>
                                <sch:assert test="(exists(@meter.count) and exists(@meter.unit)) or ($context//mei:scoreDef[1]/@meter.count and $context//mei:scoreDef[1]/@meter.unit)">
                                    The first scoreDef in an mdiv needs @meter.count and @meter.unit.
                                </sch:assert>
                                <sch:assert test="not(.//mei:staffDef[@meter.count or @meter.unit])">
                                    StaffDefs are not supposed to have @meter.count or @meter.unit. 
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_key" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:scoreDef">
                                <sch:let name="context" value="ancestor::mei:*[local-name() = ('score','part')][1]"/>
                                <sch:assert test="(exists(@key.sig) and exists(@key.mode)) or ($context//mei:scoreDef[1]/@key.sig and $context//mei:scoreDef[1]/@key.mode)">
                                    The first scoreDef in an mdiv needs @key.sig and @key.mode.
                                </sch:assert>
                                <sch:assert test="not(@trans.diat) and not(@trans.semi)">
                                    @trans.diat and @trans.semi are not allowed in the scoreDef
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_key_at_parts" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:parts">
                                <sch:let name="parts" value="child::mei:part"/>
                                <sch:let name="scoreDefs" value="for $part in $parts return ($part//mei:scoreDef)[1]"/>
                                <sch:let name="first.scoreDef" value="$scoreDefs[1]"/>
                                <sch:assert test="every $scoreDef in $scoreDefs satisfies ($scoreDef/@key.sig = $first.scoreDef/@key.sig and $scoreDef/@key.mode = $first.scoreDef/@key.mode)">
                                    All scoreDefs in parts need to have the same values for @key.sig and @key.mode.
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_transposing_staffDefs" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:staffDef">
                                <sch:assert test="(@trans.diat and @trans.semi and @key.sig and @key.mode) or (not(@trans.diat) and not(@trans.semi) and not(@key.sig) and not(@key.mode))">
                                    Transposing instruments need a staffDef with @trans.diat, @trans.semi, @key.sig and @key.mode. All other staffDefs may not use these at all, not even single ones of these attributes.
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="check_tstamp2" ident="check_tstamp2" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="@tstamp2">
                                <sch:assert test="contains(.,'m+')">
                                    tstamp2 values always need a measure reference. If targeting at the same measure as the start, add '0m+' in front.
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_controlevents" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:dir">
                                <sch:assert test="(not(@tstamp2) or (@extender = 'true')) and @tstamp and not(@endid) and not(@startid)">
                                    dir elements are supposed to have a @tstamp only.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule xml:id="controlevents_dynam" context="mei:dynam">
                                <sch:assert test="(not(@tstamp2) or (@extender = 'true')) and @tstamp and not(@endid) and not(@startid)">
                                    dynam elements are supposed to have a @tstamp only.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule xml:id="controlevents_fermata" context="mei:fermata">
                                <sch:let name="meter" value="preceding::mei:*[@meter.count][1]/xs:integer(@meter.count)"/>
                                <sch:assert role="warning" test="(not(@tstamp2) and not(@endid)) and ((@startid and not(@tstamp)) or (not(@startid) and @tstamp and number(@tstamp = $meter + 1)))">
                                    fermata elements are supposed to have a @startid only. Unless it is on a barline, then a @tstamp is allowed.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule xml:id="controlevents_hairpin" context="mei:hairpin">
                                <sch:assert test="@tstamp2 and @tstamp and not(@endid) and not(@startid)">
                                    hairpin elements are supposed to have a @tstamp and @tstamp2.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule context="mei:slur">
                                <sch:assert test="not(@tstamp2) and not(@tstamp) and @endid and @startid">
                                    slur elements are supposed to have a @startid and @endid.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule context="mei:tempo">
                                <sch:assert test="not(@tstamp2) and @tstamp and not(@endid) and not(@startid)">
                                    tempo elements are supposed to have a @tstamp only.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule xml:id="controlevents_tie" context="mei:tie">
                                <sch:assert test="not(@tstamp2) and not(@tstamp) and @endid and @startid">
                                    tie elements are supposed to have a @startid and @endid.
                                </sch:assert>
                            </sch:rule>
                            <sch:rule context="mei:trill">
                                <sch:assert test="not(@tstamp2) and not(@tstamp) and (not(@endid) or @extender='true') and @startid">
                                    trill elements are supposed to have a @startid only.
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_layer_content" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:layer">
                                <sch:assert test="not(count(child::mei:*)=0)">
                                    layers need content
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="check_stem.dir_dur1" ident="check_stem.dir_dur1" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:note">
                                <sch:assert test="not(@dur='1' and @stem.dir)">
                                    notes with dur="1" are not allowed to have a @stem.dir Attribute
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_text_attributes" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:syl">
                                <sch:assert test="(@wordpos='i' and @con='d') 
                                    or (@wordpos='m' and @con='d') 
                                    or (@wordpos='t' and @con='u')
                                    or (@wordpos='t' and not(@con)) 
                                    or (not(@wordpos) and not(@con))">
                                    for attribute @con only 'd' is allowed. if syl is longer than one note, of course @con="u" is allowed.
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_gracenote" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:note">
                                <sch:assert test="not(@grace) or @grace='unknown'">
                                    for attribute @grace only 'unknown' is allowed.
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="check_notes" ident="check_notes" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:note">
                                <sch:assert test="not(@fontsize) and not(@visible) and not(@tie) and not(@tstamp) and not(@tstamp2)">
                                    notes are not allowed to have @fontsize, @visible, @tie, @tstamp and @tstamp2
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="check_chords" ident="check_chord" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:chord">
                                <sch:assert test="not(@tie) and not(@tstamp) and not(@tstamp2)">
                                    chords are not allowed to have @tie, @tstamp and @tstamp2
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="fermata_form_shape" ident="check_fermata_form_shape" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:fermata">
                                <sch:assert test="not(form) and not(shape)">
                                    fermata is not allowed to have @form and @shape
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    
                    <constraintSpec xml:id="check_fermata_place" ident="check_fermata_place" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:fermata">
                                <sch:assert test="not(@place) or @place='below'">
                                generally @place for fermata is not needed, only @place="below" is allowed if the fermata stands below
                                </sch:assert>
                        </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_beam" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:beam">
                                <sch:assert test="not(@place)">
                                    beam is not allowed to have a @place
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_octave" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:octave">
                                <sch:assert test="not(@lform) and @startid and @endid and not(@tstamp) and not(@tstamp2)">
                                    octave is not allowed to have @lform; octave must have @startid and @endid, but is not allowed to have @tstamp and @tstamp2
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_dir" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:dir">
                                <sch:assert test="not(@label)">
                                    dir is not allowed to have @label
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_reh" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:reh">
                                <sch:assert test="not(@label) and @tstamp and not(@endid) and not(@startid)">
                                    reh should only contain a tstamp and is not allowed to have @label
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="check_dynam" ident="check_dynam" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:dynam">
                                <sch:assert test="not(@label)">
                                    dynam is not allowed to have @label
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec ident="check_rest" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:rest">
                                <sch:assert test="not(@ploc) and not(@oloc) and not(@tstamp) and not(@tstamp2)">
                                    rest is not allowed to have @ploc, @oloc, @tstamp and @tstamp2 
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                   <constraintSpec ident="check_mrest" scheme="isoschematron" mode="add">
                       <constraint>
                           <sch:rule context="mei:mrest">
                               <sch:assert test="not(@tstamp) and not(@tstamp2)">
                                   mrest is not allowed to have @tstamp and @tstamp2
                               </sch:assert>
                           </sch:rule>
                       </constraint>
                   </constraintSpec> 
                    
                   <constraintSpec ident="check_mdiv" scheme="isoschematron" mode="add">
                       <constraint>
                           <sch:rule context="mei:mdiv">
                               <sch:assert test="@n">
                                   mdiv must have @n
                               </sch:assert>
                           </sch:rule>
                       </constraint>
                   </constraintSpec>
                    
                   <constraintSpec ident="check_clef" scheme="isoschematron" mode="add">
                       <constraint>
                           <sch:rule context="mei:clef">
                               <sch:assert test="not(@tstamp) and not(@tstamp2)">
                                   clefs in a measure are not allowed to have @tstamp and @tstamp2
                               </sch:assert>
                           </sch:rule>
                       </constraint>
                   </constraintSpec>
                     
                     
                    <constraintSpec ident="check_key_in_scoreDef" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:scoreDef">
                                <sch:let name="first.in.score" value="parent::mei:score and count(preceding-sibling::mei:*) = 0"/>
                                <sch:let name="first.in.part" value="parent::mei:part and count(preceding-sibling::mei:*) = 0"/>
                                <sch:let name="has.all.info" value="@key.sig and @key.mode"/>
                                <sch:let name="parent.section" value="exists(parent::mei:section)"/>
                                <sch:let name="has.preceding" value="exists(preceding-sibling::mei:scoreDef) and exists(parent::mei:score)"/>
                                <sch:let name="all.or.nothing" value="(@key.sig and @key.mode) or (not(@key.sig) and not(@key.mode))"/>
                                <sch:assert test="($first.in.score and $has.all.info) or ($first.in.part and $has.all.info) or (($parent.section or $has.preceding) and $all.or.nothing)">
                                    scoreDef in score must have @key.sig and @key.mode; scoreDef in section must have @key.sig and @key.mode together or none of both (but not only one of this two attributes)
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>   
                    
                  <constraintSpec ident="check_keysig.showchange" scheme="isoschematron" mode="add">
                      <constraint>
                          <sch:rule context="mei:staffDef">
                              <sch:assert test="not(@keysig.showchange)">
                                  at staffDef @keysig.showchange is not allowed (use it in scoreDef)
                              </sch:assert>
                          </sch:rule>
                      </constraint>
                  </constraintSpec>
                 
                 <constraintSpec ident="check_ending_section_relationship" scheme="isoschematron" mode="add">
                     <constraint>
                         <sch:rule context="mei:ending">
                             <sch:assert role="warning" test="not(ancestor::mei:section)">
                                 A section should not contain ending elements.
                             </sch:assert>
                         </sch:rule>
                         <sch:rule context="mei:section">
                             <sch:assert role="warning" test="not(ancestor::mei:ending)">
                                 An ending should not contain section elements.
                             </sch:assert>
                         </sch:rule>
                     </constraint>
                 </constraintSpec>
                    
                    <!-- @todo -->
                    <constraintSpec ident="check_tie_similarity" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:tie">
                                <sch:let name="mdiv" value="ancestor::mei:mdiv"/>
                                <sch:let name="start.id" value="replace(@startid,'#','')"/>
                                <sch:let name="start.note" value="$mdiv//mei:*[@xml:id = $start.id]"/>
                                <sch:let name="end.id" value="replace(@endid,'#','')"/>
                                <sch:let name="end.note" value="$mdiv//mei:*[@xml:id = $end.id]"/>
                                <sch:let name="start.accid" value="if($start.note/@accid.ges) then($start.note/@accid.ges) else if($start.note/@accid) then($start.note/@accid) else('')"/>
                                <sch:let name="end.accid" value="if($end.note/@accid.ges) then($end.note/@accid.ges) else if($end.note/@accid) then($end.note/@accid) else('')"/>
                                <sch:let name="end.is.explicit" value="$end.note/@accid"/>
                                <sch:let name="start.is.chord" value="local-name($start.note) = 'chord'"/>
                                <sch:let name="end.is.chord" value="local-name($end.note) = 'chord'"/>
                                <sch:let name="both.ends.are.chords" value="$start.is.chord and $end.is.chord"/>
                                <sch:let name="has.one.chord" value="$start.is.chord or $end.is.chord and $start.is.chord ne $end.is.chord"/>
                                <sch:assert test="$both.ends.are.chords or $has.one.chord or ($start.note/@pname = $end.note/@pname)">
                                    The start and end note of a tie need to have the same @pname ("<sch:value-of select="$start.note/@pname"/>" vs. "<sch:value-of select="$end.note/@pname"/>").
                                </sch:assert>
                                <sch:assert test="$both.ends.are.chords or $has.one.chord or ($start.note/@oct = $end.note/@oct)">
                                    The start and end note of a tie need to have the same @oct  ("<sch:value-of select="$start.note/@oct"/>" vs. "<sch:value-of select="$end.note/@oct"/>").
                                </sch:assert>
                                <sch:assert test="$both.ends.are.chords or $has.one.chord or ($start.accid = $end.accid)">
                                    The start and end note of a tie need to have the same accidental settings  ("<sch:value-of select="$start.accid"/>" vs. "<sch:value-of select="$end.accid"/>").
                                </sch:assert>
                                <sch:assert test="$both.ends.are.chords or $has.one.chord or (($start.accid = $end.accid) and not($end.is.explicit))" role="info">
                                    The accidental of the end note of the tie is an @acc, not an @acc.ges as it is common, it may occured because of a page break or system break in the source
                                </sch:assert>
                                <sch:assert test="not(local-name($start.note) = 'chord' and local-name($end.note) = 'chord') or (count($start.note//mei:note) = count($end.note//mei:note))">
                                    Tied chords need to have the same number of notes  (<sch:value-of select="count($start.note//mei:note)"/> vs. <sch:value-of select="count($end.note//mei:note)"/>).
                                </sch:assert>
                                <sch:report role="info" test="local-name($start.note) = 'chord' and local-name($end.note) = 'chord'">
                                    Ties that connect chords need to be checked manually whether pitches conform.
                                </sch:report>                                
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="hairpin_between_space" ident="check_hairpin_between_space" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:hairpin">
                                <sch:assert test="not(@place='between') or (@place='between' and contains(normalize-space(@staff),' '))">
                                    if hairpin has @place=between, @staff must have a space
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                    <constraintSpec xml:id="check_dynam_between_space" ident="check_dynam_between_space" scheme="isoschematron" mode="add">
                        <constraint>
                            <sch:rule context="mei:dynam">
                                <sch:assert test="not(@place='between') or (@place='between' and contains(normalize-space(@staff),' '))">
                                    if dynam has @place=between, @staff must have a space
                                </sch:assert>
                            </sch:rule>
                        </constraint>
                    </constraintSpec>
                    
                </elementSpec>
                
                <classSpec type="atts" ident="att.note.anl.cmn" mode="delete"> 
                </classSpec>
                
                
            </schemaSpec>
        </body>
    </text>
</TEI>
