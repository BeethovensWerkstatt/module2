<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:mei="http://www.music-encoding.org/ns/mei"
    xmlns:uuid="java:java.util.UUID"
    xmlns:vife="https://edirom.de/ns/vife"
    exclude-result-prefixes="xs math xd mei uuid"
    version="3.0">
    <xd:doc scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> Oct 16, 2018</xd:p>
            <xd:p><xd:b>Author:</xd:b> Johannes Kepper</xd:p>
            <xd:p>This stylesheet allows the conversion between @tstamp- and @startid-based encoding of controlevents in MEI</xd:p>
        </xd:desc>
    </xd:doc>
    
    <!-- requirements: 
        
        valid @xml:id everywhere
        valid @tstamps on all events
        @meter.unit / @meter.count on measure (as generated by addTstamps.xsl)
    -->
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output of this stylesheet. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid and @endid to associate controlevents with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp and @tstamp2 to associate controlevents with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid / @endid and @tstamp / @tstamp2 to associate controlevents with events.</xd:li>
                <xd:li><xd:b>mixed</xd:b>: Consider specific parameters for individual behavior for different controlevents.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode" select="'id'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding slurs. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid and @endid to associate slurs with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp and @tstamp2 to associate slurs with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid / @endid and @tstamp / @tstamp2 to associate slurs with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to slurs.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.slur" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding ties. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid and @endid to associate ties with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp and @tstamp2 to associate ties with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid / @endid and @tstamp / @tstamp2 to associate ties with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to ties.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.tie" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding dynam. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate dynams with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate dynam with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate dynam with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to dynam.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.dynam" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding hairpins. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid and @endid to associate hairpins with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp and @tstamp2 to associate hairpins with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid / @endid and @tstamp / @tstamp2 to associate hairpins with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to hairpin.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.hairpin" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding dir. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate dir with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate dir with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate dir with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to dir.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.dir" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding tempo. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate tempo with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate tempo with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate tempo with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to tempo.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.tempo" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding fermata. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate fermatas with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate fermatas with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate fermatas with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to fermata.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.fermata" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding harm. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate harm with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate harm with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate harm with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to harm.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.harm" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding trill. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate trill with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate trill with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate trill with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to trill.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.trill" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding cpMarks. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid, @endid, @origin.startid etc. to associate cpMarks with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp, @tstamp2, @origin.tstamp etc. to associate cpMarks with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid etc. and @tstamp etc. to associate cpMarks with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to cpMarks.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.cpMark" select="'untouched'" as="xs:string"/>
    
    <xd:doc scope="component">
        <xd:desc>
            <xd:p>Sets the intended output regarding metaMarks. Considered only when $controlevent.assignment.mode is 
                set to 'mixed'. Allowed values are:</xd:p>
            <xd:ul>
                <xd:li><xd:b>id</xd:b>: Use @startid to associate metaMarks with events.</xd:li>
                <xd:li><xd:b>tstamp</xd:b>: Use @tstamp to associate metaMarks with events.</xd:li>
                <xd:li><xd:b>both</xd:b>: Use both @startid and @tstamp to associate metaMarks with events.</xd:li>
                <xd:li><xd:b>untouched</xd:b>: Use existing association, with no changes to metaMarks.</xd:li>
            </xd:ul>
        </xd:desc>
    </xd:doc>
    <xsl:param name="controlevent.linking.mode.metaMark" select="'untouched'" as="xs:string"/>
    
    <xsl:template match="mei:slur | mei:tie | mei:dynam | mei:hairpin | mei:dir | mei:tempo | mei:fermata | mei:harm | mei:trill | mei:cpMark | mei:metaMark" mode="controlevent.linking">
        <xsl:variable name="hasIDs" select="vife:controlevent.linking.hasIDs(.)" as="xs:boolean"/>
        <xsl:variable name="hasTstamps" select="vife:controlevent.linking.hasTstamps(.)" as="xs:boolean"/>
        
        <xsl:variable name="relevant.mode" as="xs:string">
            <xsl:choose>
                <xsl:when test="local-name() = 'slur'">
                    <xsl:value-of select="$controlevent.linking.mode.slur"/>
                </xsl:when>
                <xsl:when test="local-name() = 'tie'">
                    <xsl:value-of select="$controlevent.linking.mode.tie"/>
                </xsl:when>
                <xsl:when test="local-name() = 'dynam'">
                    <xsl:value-of select="$controlevent.linking.mode.dynam"/>
                </xsl:when>
                <xsl:when test="local-name() = 'hairpin'">
                    <xsl:value-of select="$controlevent.linking.mode.hairpin"/>
                </xsl:when>
                <xsl:when test="local-name() = 'dir'">
                    <xsl:value-of select="$controlevent.linking.mode.dir"/>
                </xsl:when>
                <xsl:when test="local-name() = 'tempo'">
                    <xsl:value-of select="$controlevent.linking.mode.tempo"/>
                </xsl:when>
                <xsl:when test="local-name() = 'fermata'">
                    <xsl:value-of select="$controlevent.linking.mode.fermata"/>
                </xsl:when>
                <xsl:when test="local-name() = 'harm'">
                    <xsl:value-of select="$controlevent.linking.mode.harm"/>
                </xsl:when>
                <xsl:when test="local-name() = 'trill'">
                    <xsl:value-of select="$controlevent.linking.mode.trill"/>
                </xsl:when>
                <xsl:when test="local-name() = 'cpMark'">
                    <xsl:value-of select="$controlevent.linking.mode.cpMark"/>
                </xsl:when>
                <xsl:when test="local-name() = 'metaMark'">
                    <xsl:value-of select="$controlevent.linking.mode.metaMark"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:variable name="mode.id" select="$controlevent.linking.mode = 'id' or ($controlevent.linking.mode = 'mixed' and $relevant.mode = 'id')" as="xs:boolean"/>
        <xsl:variable name="mode.tstamp" select="$controlevent.linking.mode = 'tstamp' or ($controlevent.linking.mode = 'mixed' and $relevant.mode = 'tstamp')" as="xs:boolean"/>
        <xsl:variable name="mode.both" select="$controlevent.linking.mode = 'both' or ($controlevent.linking.mode = 'mixed' and $relevant.mode = 'both')" as="xs:boolean"/>
        <xsl:variable name="mode.untouched" select="$controlevent.linking.mode = 'mixed' and $relevant.mode = 'untouched'" as="xs:boolean"/>
        
        <xsl:variable name="mode" as="xs:string">
            <xsl:choose>
                <xsl:when test="$mode.id">
                    <xsl:value-of select="'id'"/>
                </xsl:when>
                <xsl:when test="$mode.tstamp">
                    <xsl:value-of select="'tstamp'"/>
                </xsl:when>
                <xsl:when test="$mode.both">
                    <xsl:value-of select="'both'"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="'untouched'"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:next-match>
            <xsl:with-param name="mode" select="$mode" as="xs:string" tunnel="yes"/>
        </xsl:next-match>
        
        <!--<xsl:choose>
            <!-\- no data is available -\->
            <xsl:when test="not($hasIDs) and not($hasTstamps)">
                <xsl:choose>
                    <xsl:when test="$mode.untouched">
                        <xsl:next-match>
                            <xsl:with-param name="mode" select="'untouched'" tunnel="yes"/>
                        </xsl:next-match>
                    </xsl:when>
                    <xsl:when test="local-name() = ('dynam','dir','hairpin','dir','tempo','fermata','trill','metaMark')">
                        <xsl:variable name="start" select="vife:controlevent.linking.getStartElem(.)" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($start)">
                                <xsl:next-match>
                                    <xsl:with-param name="mode" select="$mode" tunnel="yes"/>
                                </xsl:next-match>
                            </xsl:when>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="local-name() = ('slur','tie')">
                        <xsl:variable name="start" select="vife:controlevent.linking.getStartElem(.)" as="node()?"/>
                        <xsl:variable name="end" select="vife:controlevent.linking.getEndElem(.)" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($start) and exists($end)">
                                <xsl:next-match>
                                    <xsl:with-param name="mode" select="$mode" tunnel="yes"/>
                                </xsl:next-match>
                            </xsl:when>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="local-name() = ('cpMark')">
                        <xsl:variable name="start" select="vife:controlevent.linking.getStartElem(.)" as="node()?"/>
                        <xsl:variable name="end" select="vife:controlevent.linking.getEndElem(.)" as="node()?"/>
                        <xsl:variable name="origin" select="vife:controlevent.linking.getOriginElem(.)" as="node()?"/>
                        <xsl:variable name="origin.end" select="vife:controlevent.linking.getOriginEndElem(.)" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($start) and exists($end) and exists($origin) and exists($origin.end)">
                                <xsl:next-match>
                                    <xsl:with-param name="mode" select="$mode" tunnel="yes"/>
                                </xsl:next-match>
                            </xsl:when>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message select="'ERROR (controlevent.linking): mei:' || local-name() || '#' || @xml:id || ' has neither @startid nor @tstamp â€“ further processing impossible.' "/>
                        <xsl:next-match>
                            <xsl:with-param name="mode" select="'untouched'" tunnel="yes"/>
                        </xsl:next-match>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            
            <xsl:when test="$mode.id and $hasIDs">
                <xsl:apply-templates select="." mode="controlevent.linking_strip.tstamps"/>
            </xsl:when>
            <xsl:when test="$mode.id and not($hasIDs)">
                <xsl:apply-templates select="." mode="controlevent.linking_add.IDs">
                    <xsl:with-param name="strip.tstamps" select="true()" tunnel="yes" as="xs:boolean"/>
                </xsl:apply-templates>
            </xsl:when>
            
            <xsl:when test="$mode.tstamp and $hasTstamps">
                <xsl:apply-templates select="." mode="controlevent.linking_strip.IDs"/>
            </xsl:when>
            <xsl:when test="$mode.tstamp and not($hasTstamps)">
                <xsl:apply-templates select="." mode="controlevent.linking_add.tstamps">
                    <xsl:with-param name="strip.IDs" select="true()" tunnel="yes" as="xs:boolean"/>
                </xsl:apply-templates>
            </xsl:when>
            
            <xsl:when test="$mode.both and $hasIDs and $hasTstamps">
                <xsl:next-match/>
            </xsl:when>
            <xsl:when test="$mode.both and $hasIDs and not($hasTstamps)">
                <xsl:apply-templates select="." mode="controlevent.linking_add.tstamps"/>
            </xsl:when>
            <xsl:when test="$mode.both and not($hasIDs) and $hasTstamps">
                <xsl:apply-templates select="." mode="controlevent.linking_add.IDs"/>
            </xsl:when>
            
            <xsl:when test="$mode.untouched">
                <xsl:next-match/>
            </xsl:when>
            
        </xsl:choose>-->
    </xsl:template>
    
    <!-- generate IDs from tstamp-based info -->
    <xsl:template match="@tstamp" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string?"/>
        
        <xsl:if test="not($mode)">
            <!-- this is an event -->
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('tstamp','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','id') and not(parent::mei:*/@startid)">
            <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem(parent::mei:*)" as="node()?"/>
            <xsl:if test="$start.elem">
                <xsl:attribute name="startid" select="'#' || $start.elem/@xml:id"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@tstamp2" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string?"/>
        
        <xsl:if test="not($mode)">
            <!-- this must be an event -->
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('tstamp','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','id') and not(parent::mei:*/@endid)">
            <xsl:variable name="end.elem" select="vife:controlevent.linking.getEndElem(parent::mei:*)" as="node()?"/>
            <xsl:if test="$end.elem">
                <xsl:attribute name="endid" select="'#' || $end.elem/@xml:id"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@origin.tstamp" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string"/>
        
        <xsl:if test="$mode = ('tstamp','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','id') and not(parent::mei:*/@origin.startid)">
            <xsl:variable name="origin.elem" select="vife:controlevent.linking.getOriginElem(parent::mei:*)" as="node()?"/>
            <xsl:if test="$origin.elem">
                <xsl:attribute name="origin.startid" select="'#' || $origin.elem/@xml:id"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@origin.tstamp2" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string"/>
        
        <xsl:if test="$mode = ('tstamp','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','id') and not(parent::mei:*/@origin.endid)">
            <xsl:variable name="origin.end.elem" select="vife:controlevent.linking.getOriginEndElem(parent::mei:*)" as="node()?"/>
            <xsl:if test="$origin.end.elem">
                <xsl:attribute name="origin.endid" select="'#' || $origin.end.elem/@xml:id"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    
    <!-- generate tstamps from ID-based info -->
    <xsl:template match="@startid" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string?"/>
        
        <xsl:if test="not($mode)">
            <!-- this could be a tuplet -->
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('id','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','tstamp') and not(parent::mei:*/@tstamp)">
            <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem(parent::mei:*)" as="node()?"/>
            <xsl:choose>
                <xsl:when test="$start.elem">
                    <xsl:choose>
                        <xsl:when test="local-name($start.elem) = 'measure'">
                            <xsl:attribute name="tstamp" select="1"/>
                        </xsl:when>
                        <xsl:when test="local-name($start.elem) = 'staff'">
                            <xsl:attribute name="tstamp" select="1"/>
                            <xsl:if test="not(parent::mei:*/@staff)">
                                <xsl:attribute name="staff" select="$start.elem/@n"/>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="local-name($start.elem) = 'layer'">
                            <xsl:attribute name="tstamp" select="1"/>
                            <xsl:if test="not(parent::mei:*/@staff)">
                                <xsl:attribute name="staff" select="$start.elem/parent::mei:staff/@n"/>
                            </xsl:if>
                            <xsl:if test="not(parent::mei:*/@layer) and $start.elem/@n">
                                <xsl:attribute name="layer" select="$start.elem/@n"/>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$start.elem/@tstamp">
                            <xsl:attribute name="tstamp" select="$start.elem/@tstamp"/>
                            <xsl:if test="not(parent::mei:*/@staff)">
                                <xsl:variable name="staff" select="$start.elem/ancestor::mei:staff" as="node()"/>
                                <xsl:attribute name="staff" select="$staff/@n"/>
                                <xsl:if test="count($staff/mei:layer) gt 1 and $start.elem/ancestor::mei:layer/@n">
                                    <xsl:attribute name="layer" select="$start.elem/ancestor::mei:layer/@n"/>
                                </xsl:if>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$start.elem/ancestor::mei:chord and $start.elem/ancestor::mei:chord/@tstamp">
                            <xsl:attribute name="tstamp" select="$start.elem/ancestor::mei:chord/@tstamp"/>
                            <xsl:if test="not(parent::mei:*/@staff)">
                                <xsl:variable name="staff" select="$start.elem/ancestor::mei:staff" as="node()"/>
                                <xsl:attribute name="staff" select="$staff/@n"/>
                                <xsl:if test="count($staff/mei:layer) gt 1 and $start.elem/ancestor::mei:layer/@n">
                                    <xsl:attribute name="layer" select="$start.elem/ancestor::mei:layer/@n"/>
                                </xsl:if>
                            </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="'WARNING (controlevent.linking): ' || local-name($start.elem)
                                || '#' || $start.elem/@xml:id || ' pointed at as @startid from ' 
                                || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                || ' has no @tstamp. Unable to add that to the ' || local-name(parent::mei:*) || '.'"/>
                            <!-- if this fails, preserve ID despite the mode -->
                            <xsl:if test="$mode = 'tstamp'">
                                <xsl:next-match/>
                            </xsl:if>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="'WARNING (controlevent.linking): ' 
                        || ' Unable to find element pointed at by @startid from ' 
                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                        || '. No @tstamp has been added.'"/>
                    <!-- if this fails, preserve ID despite the mode -->
                    <xsl:if test="$mode = 'tstamp'">
                        <xsl:next-match/>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@endid" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string?"/>
        
        <xsl:if test="not($mode)">
            <!-- this could be a tuplet or similar -->
            <xsl:next-match/>
        </xsl:if>
        
        <xsl:if test="$mode = ('id','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','tstamp') and not(parent::mei:*/@tstamp2)">
            <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem(parent::mei:*)" as="node()?"/>
            <xsl:variable name="end.elem" select="vife:controlevent.linking.getEndElem(parent::mei:*)" as="node()?"/>
            <xsl:choose>
                <xsl:when test="$start.elem and $end.elem">
                    <xsl:choose>
                        <xsl:when test="$start.elem/ancestor::mei:mdiv/@xml:id != $end.elem/ancestor::mei:mdiv/@xml:id">
                            <xsl:message select="'WARNING (controlevent.linking): @endid at ' 
                                || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                || ' seems to point into a different movement. @tstamp2 could not be generated.'"/>
                            <!-- if this fails, preserve ID despite the mode -->
                            <xsl:if test="$mode = 'tstamp'">
                                <xsl:next-match/>
                            </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:variable name="measure.dist" select="string(count($end.elem/preceding::mei:measure) - count($start.elem/preceding::mei:measure))" as="xs:string"/>
                            <xsl:choose>
                                <xsl:when test="local-name($end.elem) = 'measure'">
                                    <xsl:attribute name="tstamp2" select="$measure.dist || 'm+' || string(xs:integer($end.elem/@meter.count) + 1)"/>
                                </xsl:when>
                                <xsl:when test="local-name($end.elem) = ('staff','layer')">
                                    <xsl:attribute name="tstamp2" select="$measure.dist || 'm+' || string(xs:integer($end.elem/@meter.count) + 1)"/>
                                </xsl:when>
                                <xsl:when test="$end.elem/@tstamp">
                                    <xsl:attribute name="tstamp2" select="$measure.dist || 'm+' || $end.elem/@tstamp"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'WARNING (controlevent.linking): ' || local-name($end.elem)
                                        || '#' || $end.elem/@xml:id || ' pointed at as @endid from ' 
                                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                        || ' has no @tstamp. Unable to add that as tstamp2 to the ' || local-name(parent::mei:*) || '.'"/>
                                    <!-- if this fails, preserve ID despite the mode -->
                                    <xsl:if test="$mode = 'tstamp'">
                                        <xsl:next-match/>
                                    </xsl:if>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="'WARNING (controlevent.linking): ' 
                        || ' Unable to find both start and end for ' 
                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                        || '. No @tstamp2 has been added.'"/>
                    <!-- if this fails, preserve ID despite the mode -->
                    <xsl:if test="$mode = 'tstamp'">
                        <xsl:next-match/>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@origin.startid" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string"/>
        
        <xsl:message select="'Processing cpMark ' || parent::mei:*/@xml:id || ' in $mode ' || $mode"/>
        
        <xsl:if test="$mode = ('id','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','tstamp') and not(parent::mei:*/@origin.tstamp)">
            <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem(parent::mei:*)" as="node()?"/>
            <xsl:variable name="origin.elem" select="vife:controlevent.linking.getOriginElem(parent::mei:*)" as="node()?"/>
            
            <xsl:choose>
                <xsl:when test="$start.elem and $origin.elem">
                    <xsl:choose>
                        <xsl:when test="$start.elem/ancestor::mei:mdiv/@xml:id != $origin.elem/ancestor::mei:mdiv/@xml:id">
                            <xsl:message select="'WARNING (controlevent.linking): @origin.startid at ' 
                                || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                || ' seems to point into a different movement. @origin.tstamp could not be generated.'"/>
                            <xsl:message select="'Start: ' || $start.elem/ancestor::mei:mdiv/@xml:id || ' vs. Origin: ' || $origin.elem/ancestor::mei:mdiv/@xml:id"></xsl:message>
                            <!-- if this fails, preserve ID despite the mode -->
                            <xsl:if test="$mode = 'tstamp'">
                                <xsl:next-match/>
                            </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:variable name="measure.dist" select="string(count($origin.elem/preceding::mei:measure) - count($start.elem/preceding::mei:measure))" as="xs:string"/>
                            <xsl:choose>
                                <xsl:when test="local-name($origin.elem) = 'measure'">
                                    <xsl:attribute name="origin.tstamp" select="$measure.dist || 'm+1'"/>
                                </xsl:when>
                                <xsl:when test="local-name($origin.elem) = 'staff' and local-name($start.elem) = 'staff'">
                                    <xsl:attribute name="origin.tstamp" select="$measure.dist || 'm+1'"/>
                                    <xsl:if test="($start.elem/@n != $origin.elem/@n) and not(parent::mei:*/@origin.staff)">
                                        <xsl:attribute name="origin.staff" select="$origin.elem/@n"/>
                                    </xsl:if>
                                </xsl:when>
                                <xsl:when test="local-name($origin.elem) = 'layer'">
                                    <xsl:attribute name="origin.tstamp" select="$measure.dist || 'm+1'"/>
                                    <xsl:if test="($start.elem/parent::mei:staff/@n != $origin.elem/parent::mei:staff/@n) and not(parent::mei:*/@origin.staff)">
                                        <xsl:attribute name="origin.staff" select="$origin.elem/@n"/>
                                    </xsl:if>
                                    <xsl:if test="$origin.elem/@n and not(parent::mei:*/@origin.layer)">
                                        <xsl:attribute name="origin.layer" select="$origin.elem/@n"/>
                                    </xsl:if>
                                </xsl:when>
                                <xsl:when test="$origin.elem/@tstamp">
                                    <xsl:attribute name="origin.tstamp" select="$measure.dist || 'm+' || $origin.elem/@tstamp"/>
                                    
                                    <xsl:variable name="start.staff" select="$start.elem/ancestor::mei:staff" as="node()"/>
                                    <xsl:variable name="origin.staff" select="$origin.elem/ancestor::mei:staff" as="node()"/>
                                    <xsl:if test="($start.staff/@n != $origin.staff/@n) and not(parent::mei:*/@origin.staff)">
                                        <xsl:attribute name="origin.staff" select="$origin.staff/@n"/>
                                        <xsl:if test="count($origin.staff/mei:layer) gt 1 and $origin.elem/ancestor::mei:layer/@n">
                                            <xsl:attribute name="origin.layer" select="$origin.elem/ancestor::mei:layer/@n"/>
                                        </xsl:if>
                                    </xsl:if>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'WARNING (controlevent.linking): ' || local-name($origin.elem)
                                        || '#' || $origin.elem/@xml:id || ' pointed at as @origin.startid from ' 
                                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                        || ' has no @tstamp. Unable to add that as origin.tstamp to the ' || local-name(parent::mei:*) || '.'"/>
                                    <!-- if this fails, preserve ID despite the mode -->
                                    <xsl:if test="$mode = 'tstamp'">
                                        <xsl:next-match/>
                                    </xsl:if>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="'WARNING (controlevent.linking): ' 
                        || ' Unable to find both start and origin for ' 
                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                        || '. No @origin.tstamp has been added.'"/>
                    <!-- if this fails, preserve ID despite the mode -->
                    <xsl:if test="$mode = 'tstamp'">
                        <xsl:next-match/>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@origin.endid" mode="controlevent.linking">
        <xsl:param name="mode" tunnel="yes" as="xs:string"/>
        
        <xsl:if test="$mode = ('id','untouched','both')">
            <xsl:next-match/>
        </xsl:if>
        <xsl:if test="$mode = ('both','tstamp') and not(parent::mei:*/@tstamp2)">
            <xsl:variable name="origin.elem" select="vife:controlevent.linking.getOriginElem(parent::mei:*)" as="node()?"/>
            <xsl:variable name="origin.end.elem" select="vife:controlevent.linking.getOriginEndElem(parent::mei:*)" as="node()?"/>
            <xsl:choose>
                <xsl:when test="$origin.elem and $origin.end.elem">
                    <xsl:choose>
                        <xsl:when test="$origin.elem/ancestor::mei:mdiv/@xml:id != $origin.end.elem/ancestor::mei:mdiv/@xml:id">
                            <xsl:message select="'WARNING (controlevent.linking): @origin.endid at ' 
                                || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                || ' seems to point into a different movement than @origin.startid. @origin.tstamp2 could not be generated.'"/>
                            <!-- if this fails, preserve ID despite the mode -->
                            <xsl:if test="$mode = 'tstamp'">
                                <xsl:next-match/>
                            </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:variable name="measure.dist" select="string(count($origin.end.elem/preceding::mei:measure) - count($origin.elem/preceding::mei:measure))" as="xs:string"/>
                            <xsl:choose>
                                <xsl:when test="local-name($origin.end.elem) = 'measure'">
                                    <!-- todo: hier weiter debuggen -->
                                    <xsl:if test=". = '#kitzler-004_m-47'">
                                        <xsl:message select="'ALARM ' || ."/>
                                    </xsl:if>
                                    <xsl:attribute name="tstamp2" select="$measure.dist || 'm+' || string(xs:integer($origin.end.elem/@meter.count) + 1)"/>
                                </xsl:when>
                                <xsl:when test="local-name($origin.end.elem) = ('staff','layer')">
                                    <xsl:attribute name="tstamp2" select="$measure.dist || 'm+' || string(xs:integer($origin.end.elem/@meter.count) + 1)"/>
                                </xsl:when>
                                <xsl:when test="$origin.end.elem/@tstamp">
                                    <xsl:attribute name="tstamp2" select="$measure.dist || 'm+' || $origin.end.elem/@tstamp"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message select="'WARNING (controlevent.linking): ' || local-name($origin.end.elem)
                                        || '#' || $origin.end.elem/@xml:id || ' pointed at as @endid from ' 
                                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                                        || ' has no @tstamp. Unable to add that as tstamp2 to the ' || local-name(parent::mei:*) || '.'"/>
                                    <!-- if this fails, preserve ID despite the mode -->
                                    <xsl:if test="$mode = 'tstamp'">
                                        <xsl:next-match/>
                                    </xsl:if>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="'WARNING (controlevent.linking): ' 
                        || ' Unable to find both origin.start and origin.end for ' 
                        || local-name(parent::mei:*) || '#' || parent::mei:*/@xml:id 
                        || '. No @tstamp2 has been added.'"/>
                    <!-- if this fails, preserve ID despite the mode -->
                    <xsl:if test="$mode = 'tstamp'">
                        <xsl:next-match/>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    
    <!-- This function tests if an element uses @startid and, if necessary, @endid -->
    <xsl:function name="vife:controlevent.linking.hasIDs" as="xs:boolean">
        <xsl:param name="elem" as="node()"/>
        <xsl:choose>
            <xsl:when test="local-name($elem) = 'slur'">
                <xsl:value-of select="exists($elem/@startid) and exists($elem/@endid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'tie'">
                <xsl:value-of select="exists($elem/@startid) and exists($elem/@endid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'dynam'">
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'hairpin'">
                <xsl:value-of select="exists($elem/@startid) and exists($elem/@endid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'dir'">
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'tempo'">
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'fermata'">
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'harm'">
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'trill'">
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'cpMark'">
                <xsl:value-of select="exists($elem/@startid) and exists($elem/@endid) and exists($elem/@origin.startid) and exists($elem/@origin.endid)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'metaMark'">
                <xsl:value-of select="exists($elem/@startid) and exists($elem/@endid)"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- handling of unspecified controlevents -->
                <xsl:value-of select="exists($elem/@startid)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <!-- This function tests if an element uses @tstamp, @staff and, if necessary, @tstamp2 -->
    <xsl:function name="vife:controlevent.linking.hasTstamps" as="xs:boolean">
        <xsl:param name="elem" as="node()"/>
        <xsl:choose>
            <xsl:when test="local-name($elem) = 'slur'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff) and exists($elem/@tstamp2)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'tie'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff) and exists($elem/@tstamp2)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'dynam'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'hairpin'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff) and exists($elem/@tstamp2)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'dir'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'tempo'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'fermata'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'harm'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'trill'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'cpMark'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff) and exists($elem/@tstamp2) and exists($elem/@origin.tstamp) and exists($elem/@origin.tstamp2)"/>
            </xsl:when>
            <xsl:when test="local-name($elem) = 'metaMark'">
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff) and exists($elem/@tstamp2)"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- handling of unspecified controlevents -->
                <xsl:value-of select="exists($elem/@tstamp) and exists($elem/@staff)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="vife:controlevent.linking.hasStart" as="xs:boolean">
        <xsl:param name="elem" as="node()"/>
        <xsl:choose>
            <xsl:when test="$elem/@startid">
                <xsl:value-of select="true()"/>
            </xsl:when>
            <xsl:when test="$elem/@tstamp and ($elem/@staff or local-name($elem) = 'cpMark')">
                <!-- cpMarks may affect complete measures -->
                <xsl:value-of select="true()"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="false()"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    <xsl:function name="vife:controlevent.linking.hasEnd" as="xs:boolean">
        <xsl:param name="elem" as="node()"/>
        <xsl:choose>
            <xsl:when test="$elem/@endid">
                <xsl:value-of select="true()"/>
            </xsl:when>
            <xsl:when test="$elem/@tstamp2 and ($elem/@staff or $elem/@startid or local-name($elem) = 'cpMark')">
                <xsl:value-of select="true()"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="false()"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    
    <xsl:function name="vife:controlevent.linking.getStartElem" as="node()?">
        <xsl:param name="input.elem" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="$input.elem/@startid">
                <xsl:variable name="target" select="vife:controlevent.linking.retrieve.link($input.elem/@startid)" as="node()?"/>
                
                <xsl:choose>
                    <xsl:when test="not($target)">
                        <xsl:message select="'WARNING (controlevent.linking): Broken link at mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' (@startid). No @tstamp generated.'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="$target"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="current.tstamp" select="$input.elem/@tstamp" as="xs:string"/>
                <xsl:variable name="staff.n" as="xs:string?">
                    <xsl:choose>
                        <xsl:when test="$input.elem/@staff">
                            <xsl:value-of select="$input.elem/@staff"/>
                        </xsl:when>
                        <xsl:when test="count($input.elem/ancestor::mei:measure/mei:staff) = 1">
                            <xsl:value-of select="'1'"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                
                <xsl:choose>
                    <!-- special case: cpMarks that affect complete measures -->
                    <xsl:when test="not($staff.n) and local-name($input.elem) = 'cpMark'">
                        <xsl:sequence select="$input.elem/ancestor::mei:measure"/>
                    </xsl:when>
                    <!-- missing @staff -->
                    <xsl:when test="not($staff.n)">
                        <xsl:message select="'WARNING (controlevent.linking): Missing @staff at mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:variable name="staff" select="$input.elem/ancestor::mei:measure/mei:staff[@n = $staff.n]" as="node()"/>
                        <xsl:variable name="layer.n" select="$input.elem/@layer" as="xs:string?"/>
                        
                        <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                            then($staff/mei:layer[@n = $layer.n]) 
                            else($staff)" as="node()"/>
                        
                        <xsl:variable name="target" select="($scope//mei:*[@tstamp = $current.tstamp])[1]" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($target)">
                                <xsl:sequence select="$target"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): No target found for mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ', based on @tstamp ' || $input.elem/@tstamp ||' and @staff ' || $input.elem/@staff || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="vife:controlevent.linking.getEndElem" as="node()?">
        <xsl:param name="input.elem" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="$input.elem/@endid">
                <xsl:variable name="target" select="vife:controlevent.linking.retrieve.link($input.elem/@endid)" as="node()?"/>
                
                <xsl:choose>
                    <xsl:when test="not($target)">
                        <xsl:message select="'WARNING (controlevent.linking): Broken link at mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' (@endid).'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="$target"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="current.tstamp2" select="$input.elem/@tstamp2" as="xs:string"/>
                <xsl:variable name="target.tstamp" select="substring-after($current.tstamp2,'m+')" as="xs:string"/>
                <xsl:variable name="measure.dist" select="xs:integer(substring-before($current.tstamp2,'m+'))" as="xs:integer"/>
                <xsl:variable name="current.measure" select="$input.elem/ancestor::mei:measure" as="node()"/>
                <xsl:variable name="target.measure" select="if($measure.dist = 0) then($current.measure) else($current.measure/following::mei:measure[$measure.dist])" as="node()?"/>
                
                <xsl:variable name="staff.n" as="xs:string?">
                    <xsl:choose>
                        <xsl:when test="$input.elem/@staff">
                            <xsl:value-of select="$input.elem/@staff"/>
                        </xsl:when>
                        <xsl:when test="count($input.elem/ancestor::mei:measure/mei:staff) = 1">
                            <xsl:value-of select="'1'"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                
                <xsl:choose>
                    <xsl:when test="not($target.measure)">
                        <xsl:message select="'WARNING (controlevent.linking): Unable to identify target measure for @tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                    </xsl:when>
                    <xsl:when test="local-name($input.elem) = 'cpMark' and not($staff.n)">
                        <xsl:choose>
                            <!-- it seems like the whole measure with all staves is meant -->
                            <xsl:when test="number($target.tstamp) ge number($target.measure/@meter.count)">
                                <xsl:sequence select="$target.measure"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @tstamp2 ' || $current.tstamp2 || ' of mei:cpMark#' || $input.elem/@xml:id || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="not($staff.n)">
                        <!-- try to retrieve staff from start elem -->
                        <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem($input.elem)" as="node()"/>
                        <xsl:variable name="start.staff" select="$start.elem/ancestor::mei:staff/@n" as="xs:string?"/>
                        <xsl:choose>
                            <xsl:when test="$start.staff">
                                <xsl:variable name="staff" select="$target.measure/mei:staff[@n = $start.staff]" as="node()"/>
                                <xsl:variable name="layer.n" select="$input.elem/@layer" as="xs:string?"/>
                                
                                <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                                    then($staff/mei:layer[@n = $layer.n]) 
                                    else($staff)" as="node()"/>
                                
                                <xsl:variable name="target" select="($scope//mei:*[@tstamp = $target.tstamp])[1]" as="node()?"/>
                                <xsl:choose>
                                    <xsl:when test="exists($target)">
                                        <xsl:sequence select="$target"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="count($target.measure//mei:*[@tstamp = $target.tstamp]) = 1">
                                <!-- there is only one possible target in this measure -->
                                <xsl:sequence select="$target.measure//mei:*[@tstamp = $target.tstamp]"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' because the staff is unknown.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <!-- staff is known -->
                    <xsl:otherwise>
                        <xsl:variable name="staff" select="$target.measure/mei:staff[@n = $staff.n]" as="node()"/>
                        <xsl:variable name="layer.n" select="$input.elem/@layer" as="xs:string?"/>
                        
                        <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                            then($staff/mei:layer[@n = $layer.n]) 
                            else($staff)" as="node()"/>
                        
                        <xsl:variable name="target" select="($scope//mei:*[@tstamp = $target.tstamp])[1]" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($target)">
                                <xsl:sequence select="$target"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
                
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="vife:controlevent.linking.getOriginElem" as="node()?">
        <xsl:param name="input.elem" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="$input.elem/@origin.startid">
                <xsl:variable name="target" select="vife:controlevent.linking.retrieve.link($input.elem/@origin.startid)" as="node()?"/>
                
                <xsl:choose>
                    <xsl:when test="not($target)">
                        <xsl:message select="'WARNING (controlevent.linking): Broken link at mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' (@endid).'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="$target"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="origin.tstamp" select="$input.elem/@origin.tstamp" as="xs:string"/>
                <xsl:variable name="target.tstamp" select="substring-after($origin.tstamp,'m+')" as="xs:string"/>
                <xsl:variable name="measure.dist" select="xs:integer(substring-before($origin.tstamp,'m+'))" as="xs:integer"/>
                <xsl:variable name="current.measure" select="$input.elem/ancestor::mei:measure" as="node()"/>
                <xsl:variable name="target.measure" select="if($measure.dist = 0) then($current.measure) else($current.measure/preceding::mei:measure[abs($measure.dist)])" as="node()?"/>
                
                <xsl:message select="'DEBUG: ' || $current.measure/preceding::mei:measure[abs($measure.dist)]/@xml:id"></xsl:message>
                
                <xsl:variable name="staff.n" as="xs:string?">
                    <xsl:choose>
                        <xsl:when test="$input.elem/@origin.staff">
                            <xsl:value-of select="$input.elem/@origin.staff"/>
                        </xsl:when>
                        <xsl:when test="$input.elem/@staff">
                            <xsl:value-of select="$input.elem/@staff"/>
                        </xsl:when>
                        <xsl:when test="count($input.elem/ancestor::mei:measure/mei:staff) = 1">
                            <xsl:value-of select="'1'"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                
                <xsl:choose>
                    <xsl:when test="not($target.measure)">
                        <xsl:message select="'WARNING (controlevent.linking): Unable to identify target measure for @origin.tstamp ' || $origin.tstamp || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                    </xsl:when>
                    <xsl:when test="local-name($input.elem) = 'cpMark' and not($staff.n)">
                        <xsl:choose>
                            <!-- it seems like the whole measure with all staves is meant -->
                            <xsl:when test="number($target.tstamp) ge number($target.measure/@meter.count)">
                                <xsl:sequence select="$target.measure"/>
                            </xsl:when>
                            <xsl:when test="'lazy' = 'lazy'">
                                <!-- maybe no @staff has been provided, but still a clean cut is intended -->
                                <xsl:sequence select="$target.measure"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp ' || $origin.tstamp || ' of mei:cpMark#' || $input.elem/@xml:id || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="not($staff.n)">
                        <!-- try to retrieve staff from start elem -->
                        <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem($input.elem)" as="node()"/>
                        <xsl:variable name="start.staff" select="$start.elem/ancestor::mei:staff/@n" as="xs:string?"/>
                        <xsl:choose>
                            <xsl:when test="$start.staff">
                                <xsl:variable name="staff" select="$target.measure/mei:staff[@n = $start.staff]" as="node()"/>
                                <xsl:variable name="layer.n" select="$input.elem/@layer" as="xs:string?"/>
                                
                                <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                                    then($staff/mei:layer[@n = $layer.n]) 
                                    else($staff)" as="node()"/>
                                
                                <xsl:variable name="target" select="($scope//mei:*[@tstamp = $target.tstamp])[1]" as="node()?"/>
                                <xsl:choose>
                                    <xsl:when test="exists($target)">
                                        <xsl:sequence select="$target"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp ' || $origin.tstamp || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="count($target.measure//mei:*[@tstamp = $target.tstamp]) = 1">
                                <!-- there is only one possible target in this measure -->
                                <xsl:sequence select="$target.measure//mei:*[@tstamp = $target.tstamp]"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp ' || $origin.tstamp || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' because the staff is unknown.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <!-- staff is known -->
                    <xsl:otherwise>
                        <xsl:variable name="staff" select="$target.measure/mei:staff[@n = $staff.n]" as="node()"/>
                        <xsl:variable name="layer.n" select="$input.elem/@layer" as="xs:string?"/>
                        
                        <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                            then($staff/mei:layer[@n = $layer.n]) 
                            else($staff)" as="node()"/>
                        
                        <xsl:variable name="target" select="($scope//mei:*[@tstamp = $target.tstamp])[1]" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($target)">
                                <xsl:sequence select="$target"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp ' || $origin.tstamp || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
                
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="vife:controlevent.linking.getOriginEndElem" as="node()?">
        <xsl:param name="input.elem" as="node()"/>
        
        <xsl:choose>
            <xsl:when test="$input.elem/@origin.endid">
                <xsl:variable name="target" select="vife:controlevent.linking.retrieve.link($input.elem/@origin.endid)" as="node()?"/>
                
                <xsl:choose>
                    <xsl:when test="not($target)">
                        <xsl:message select="'WARNING (controlevent.linking): Broken link at mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' (@origin.endid).'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="$target"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="current.tstamp2" select="$input.elem/@origin.tstamp2" as="xs:string"/>
                <xsl:variable name="target.tstamp" select="substring-after($current.tstamp2,'m+')" as="xs:string"/>
                <xsl:variable name="measure.dist" select="xs:integer(substring-before($current.tstamp2,'m+'))" as="xs:integer"/>
                <xsl:variable name="current.measure" select="vife:controlevent.linking.getOriginElem($input.elem)/ancestor-or-self::mei:measure" as="node()?"/>
                <xsl:if test="not($current.measure)">
                    <xsl:message select="vife:controlevent.linking.getOriginElem($input.elem)"/>
                    <xsl:message select="' - '"></xsl:message>
                    <xsl:message select="$input.elem" terminate="yes"/>
                </xsl:if>
                <xsl:variable name="target.measure" select="if($measure.dist = 0) then($current.measure) else($current.measure/following::mei:measure[$measure.dist])" as="node()"/>
                
                <xsl:variable name="staff.n" as="xs:string?">
                    <xsl:choose>
                        <xsl:when test="$input.elem/@origin.staff">
                            <xsl:value-of select="$input.elem/@origin.staff"/>
                        </xsl:when>
                        <xsl:when test="$input.elem/@staff">
                            <xsl:value-of select="$input.elem/@staff"/>
                        </xsl:when>
                        <xsl:when test="count($input.elem/ancestor::mei:measure/mei:staff) = 1">
                            <xsl:value-of select="'1'"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                
                <xsl:choose>
                    <xsl:when test="local-name($input.elem) = 'cpMark' and not($staff.n)">
                        <xsl:choose>
                            <!-- it seems like the whole measure with all staves is meant -->
                            <xsl:when test="number($target.tstamp) ge number($target.measure/@meter.count)">
                                <xsl:sequence select="$target.measure"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp2 ' || $current.tstamp2 || ' of mei:cpMark#' || $input.elem/@xml:id || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="not($staff.n)">
                        <!-- try to retrieve staff from start elem -->
                        <xsl:variable name="start.elem" select="vife:controlevent.linking.getStartElem($input.elem)" as="node()"/>
                        <xsl:variable name="start.staff" select="$start.elem/ancestor::mei:staff/@n" as="xs:string?"/>
                        <xsl:choose>
                            <xsl:when test="$start.staff">
                                <xsl:variable name="staff" select="$target.measure/mei:staff[@n = $start.staff]" as="node()"/>
                                <xsl:variable name="layer.n" as="xs:string?">
                                    <xsl:choose>
                                        <xsl:when test="$input.elem/@origin.layer">
                                            <xsl:value-of select="$input.elem/@origin.layer"/>
                                        </xsl:when>
                                        <xsl:when test="$input.elem/@layer">
                                            <xsl:value-of select="$input.elem/@layer"/>
                                        </xsl:when>
                                    </xsl:choose>
                                </xsl:variable>
                                
                                <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                                    then($staff/mei:layer[@n = $layer.n]) 
                                    else($staff)" as="node()"/>
                                
                                <xsl:variable name="target" select="($scope//mei:*[@tstamp = $target.tstamp])[1]" as="node()?"/>
                                <xsl:choose>
                                    <xsl:when test="exists($target)">
                                        <xsl:sequence select="$target"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="count($target.measure//mei:*[@tstamp = $target.tstamp]) = 1">
                                <!-- there is only one possible target in this measure -->
                                <xsl:sequence select="$target.measure//mei:*[@tstamp = $target.tstamp]"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || ' because the staff is unknown.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <!-- staff is known -->
                    <xsl:otherwise>
                        <xsl:variable name="staff" select="$target.measure/mei:staff[@n = $staff.n]" as="node()"/>
                        <xsl:variable name="layer.n" select="$input.elem/@layer" as="xs:string?"/>
                        
                        <xsl:variable name="scope" select="if($layer.n and $staff/mei:layer[@n = $layer.n]) 
                            then($staff/mei:layer[@n = $layer.n]) 
                            else($staff)" as="node()"/>
                        
                        <xsl:variable name="target" select="($scope//mei:*[@tstamp = $target.tstamp])[1]" as="node()?"/>
                        <xsl:choose>
                            <xsl:when test="exists($target)">
                                <xsl:sequence select="$target"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message select="'WARNING (controlevent.linking): Unable to identify element at @origin.tstamp2 ' || $current.tstamp2 || ' of mei:' || local-name($input.elem) || '#' || $input.elem/@xml:id || '.'"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
                
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="vife:controlevent.linking.retrieve.link" as="node()?">
        <xsl:param name="attr" as="attribute()"/>
        <xsl:variable name="link" select="string($attr)" as="xs:string"/>
        
        <xsl:choose>
            <xsl:when test="starts-with($link,'#')">
                <xsl:variable name="context" select="$attr/ancestor::mei:mdiv" as="node()"/>
                <xsl:variable name="target" select="$context//element()[@xml:id = substring($link,2)]" as="node()?"/>
                <xsl:if test="not($target)">
                    <xsl:message select="'WARNING (controlevent.linking): Broken link at mei:' || local-name($attr/parent::mei:*) || '#' || $attr/parent::mei:*/@xml:id || ' (@' || local-name($attr) || ').'"/>
                </xsl:if>
                <xsl:sequence select="$target"/>
            </xsl:when>
            <xsl:when test="contains($link,'#')">
                <xsl:variable name="doc" select="doc(substring-before($link,'#'))" as="document-node()?"/>
                <xsl:choose>
                    <xsl:when test="not($doc)">
                        <xsl:message select="'WARNING (controlevent.linking): Unable to retrieve document ' || substring-before($link,'#') || ', referenced at mei:' || local-name($attr/parent::mei:*) || '#' || $attr/parent::mei:*/@xml:id || ' (@' || local-name($attr) || ').'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:variable name="target" select="$doc/id(substring-after($link,'#'))" as="node()?"/>
                        <xsl:if test="not($target)">
                            <xsl:message select="'WARNING (controlevent.linking): Broken link at mei:' || local-name($attr/parent::mei:*) || '#' || $attr/parent::mei:*/@xml:id || ' (@' || local-name($attr) || ').'"/>
                        </xsl:if>
                        <xsl:sequence select="$target"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:function>
    
</xsl:stylesheet>